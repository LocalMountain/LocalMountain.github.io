<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="第一部分 基础知识第一章 为什么要关心Java 82014年3月更新Java 8，加入了很多新特性。 函数式编程、并行新思路、Stream API …  书中第一章节举例： Java8中提供了一个新的API（Stream），支持许多处理数据的并行操作，思路和SQL类似，将所需步骤抽象出来，具体的底层执行机制将Stream API进行实现。Stream是Java 8表示有序数据，并能灵活地表示这些数">
<meta property="og:type" content="article">
<meta property="og:title" content="Stream">
<meta property="og:url" content="http://example.com/2020/06/12/Stream/index.html">
<meta property="og:site_name" content="LocalMountain">
<meta property="og:description" content="第一部分 基础知识第一章 为什么要关心Java 82014年3月更新Java 8，加入了很多新特性。 函数式编程、并行新思路、Stream API …  书中第一章节举例： Java8中提供了一个新的API（Stream），支持许多处理数据的并行操作，思路和SQL类似，将所需步骤抽象出来，具体的底层执行机制将Stream API进行实现。Stream是Java 8表示有序数据，并能灵活地表示这些数">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-12T03:31:38.000Z">
<meta property="article:modified_time" content="2021-08-08T14:39:55.557Z">
<meta property="article:author" content="hzq">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2020/06/12/Stream/"/>





  <title>Stream | LocalMountain</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LocalMountain</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/12/Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LocalMountain">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Stream</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-12T11:31:38+08:00">
                2020-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h2><h3 id="第一章-为什么要关心Java-8"><a href="#第一章-为什么要关心Java-8" class="headerlink" title="第一章 为什么要关心Java 8"></a>第一章 为什么要关心Java 8</h3><p>2014年3月更新Java 8，加入了很多新特性。</p>
<p>函数式编程、并行新思路、Stream API …</p>
<blockquote>
<p>书中第一章节举例：</p>
<p>Java8中提供了一个新的API（Stream），支持许多处理数据的并行操作，思路和SQL类似，将所需步骤抽象出来，具体的底层执行机制将Stream API进行实现。Stream是Java 8表示有序数据，并能灵活地表示这些数据进行并行处理的新方式。在Java 8中可以透明地把输入的不相关的部分拿到几个CPU内核上分别执行，系统维持的并发。</p>
<p>Lambda实现行为参数化，用来优化匿名类，简化编码。行为参数化的功能也被称为「函数式编程」</p>
<p>接口可以对方法进行默认实现，而不是由每个继承该接口的实现类自行实现</p>
<p>使用Optional类避免NullPointer异常</p>
</blockquote>
<h3 id="第二章-通过行为参数化传递代码"><a href="#第二章-通过行为参数化传递代码" class="headerlink" title="第二章 通过行为参数化传递代码"></a>第二章 通过行为参数化传递代码</h3><p>策略模式的实现，通过更改行为达到不同的需求</p>
<p>这一章中通过「谓词」具体实现不同需求的编码。谓词即为返回一个boolean的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; inventory, ApplePredicate p)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.test(apple)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用匿名内部类来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; redApples = filterApples(inventory, <span class="keyword">new</span> ApplePredicate() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用Lambda实现，在lambda中仅包含方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; redApples = filterApples(inventory, (Apple apple) -&gt; <span class="string">&quot;red&quot;</span>.equals(apple.getColor());</span><br></pre></td></tr></table></figure>



<p><strong>另一个示例</strong>：利用Comparator进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(<span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(</span><br><span class="line">	(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br></pre></td></tr></table></figure>

<h3 id="第三章-Lambda表达式"><a href="#第三章-Lambda表达式" class="headerlink" title="第三章 Lambda表达式"></a>第三章 Lambda表达式</h3><p>lambda就是用来替代匿名类。可以将Lambda简单得理解为可传递的匿名函数的一种方式</p>
<p>lambda包含三个部分：</p>
<ol>
<li>参数列表</li>
<li>箭头-&gt;</li>
<li>方法主体</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">    或</span><br><span class="line">(parameters) -&gt; &#123;statements;&#125;</span><br></pre></td></tr></table></figure>



<p>函数式接口：仅定义一个方法的接口，接口中可以包含默认方法，只要接口只定义了一个抽象方法。在 java.util.function 包下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;  <span class="comment">// T -&gt; boolean    test()</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数描述符。Predicate即为(T) -&gt; boolean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;  <span class="comment">// T -&gt; void    accept(T t)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;  <span class="comment">// T -&gt; R    apply(T t)</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Supplier<T>    void -&gt; T  get()</p>
<p>为了避免 int 和 Integer 等类型之间的装箱和拆箱过程，函数式接口有专门针对于原始类型的版本，如使用<code>IntPredicate</code>替代<code>Predicate&lt;Integer&gt;</code></p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>函数描述符</th>
<th>原始类型特化</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
<td>IntPredicate, LongPredicate, DoublePredicate</td>
</tr>
<tr>
<td>Consumer<T></td>
<td>T -&gt; void</td>
<td>IntConsumer, LongConsumer, DoubleConsumer</td>
</tr>
<tr>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
<td>IntFunction<R>, IntToDoubleFunction, IntToDoubleFunction,<br />LongFunction<R>, LongToDoubleFunction, LongToIntFunction,<br />DoubleFunction<R>, <br />ToIntFunction<T>, ToDoubleFuntion<T>, ToLongFunction<T></td>
</tr>
<tr>
<td>Supplier<T></td>
<td>() -&gt; T</td>
<td>BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier</td>
</tr>
<tr>
<td>UnaryOperator<T></td>
<td>T -&gt; T</td>
<td>IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</td>
</tr>
<tr>
<td>BinaryOperator<T></td>
<td>(T, T) -&gt; T</td>
<td>IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator</td>
</tr>
<tr>
<td>BiPredicate&lt;L, R&gt;</td>
<td>(L, R) -&gt; boolean</td>
<td></td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>(T, U) -&gt; void</td>
<td>ObjIntConsumer<T>, ObjLongConsumer<T>, ObjDoubleConsumer<T></td>
</tr>
<tr>
<td>BiFunction&lt;T, U, R&gt;</td>
<td>(T, U) -&gt; R</td>
<td>ToIntBiFunction&lt;T, U&gt;, ToLongBiFunction&lt;T, U&gt;, ToDoubleBiFunction&lt;T, U&gt;</td>
</tr>
</tbody></table>
<p>类型检查是从Lambda上下文推断出来的</p>
<p><strong>特殊情况</strong>，对于只有一行语句，即省略return和花括号的形式，其可相当于返回void</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; p = s -&gt; list.add(s); <span class="comment">// add操作返回boolean</span></span><br><span class="line">Consumer&lt;String&gt; b = s -&gt; list.add(s);  <span class="comment">// Consumer接收void，这里add返回Boolean不会报错，因为语句表达式相当于返回void</span></span><br></pre></td></tr></table></figure>



<p>在lambda中使用局部变量<strong>有限制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> portNumber = <span class="number">1337</span>;</span><br><span class="line">Runnable r = () -&gt; System.out.println(portNumber);  <span class="comment">// 这里会隐式地将portNumber变为final</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> portNumber = <span class="number">1337</span>;</span><br><span class="line">Runnable r = () -&gt; System.out.println(portNumber);  <span class="comment">// 报错，后期进行了多次赋值，不能修改为final</span></span><br><span class="line">portNumber = <span class="number">31337</span>;</span><br></pre></td></tr></table></figure>

<p>实例变量保存在堆中，但是局部变量保存在栈中</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>传递的lambda代码有可用的方法直接解决，那么可以直接调用该方法，即为方法引用。用来简化lambda</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br><span class="line">inventory.sort(comparing(Apple::getWeight));</span><br><span class="line"></span><br><span class="line">Apple::getWeight就是lambda表达式(Apple a) -&gt; a.getWeight()地简化写法</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Lambda</th>
<th>等效的方法引用</th>
</tr>
</thead>
<tbody><tr>
<td>(Apple a) -&gt; a.getWeight()</td>
<td>Apple::getWeight</td>
</tr>
<tr>
<td>() -&gt; Thread.currentThread().dumpStack()</td>
<td>Thread.currentThread()::dumpStack</td>
</tr>
<tr>
<td>(str, i) -&gt; str.substring(i)</td>
<td>String::substring</td>
</tr>
<tr>
<td>(String s) -&gt; System.out.println(s)</td>
<td>System.out::println</td>
</tr>
</tbody></table>
<p>如表中所示，<strong>方法引用主要包含3类</strong></p>
<ol>
<li><p>指向静态方法的方法引用。类名::静态方法名  (args) -&gt; ClassName.staticMethod(args)变为ClassName::staticMethod</p>
</li>
<li><p>指向任意类型实例方法的方法引用。类名::方法名  (arg0, rest) -&gt; arg0.instanceMethod(rest)变为ClassName::instanceMethod      其中arg0即为ClassName类型的</p>
</li>
<li><p>指向现有对象的实例方法的方法引用。变量名::方法名      (args) -&gt; expr.instanceMethod(args)变为expr::instanceMethod</p>
</li>
</ol>
<p><strong>特殊情况</strong>：</p>
<p>构造函数的引用：ClassName::new</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有趣的应用</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;String, Function&lt;Integer, Fruit&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;apple&quot;</span>, Apple::<span class="keyword">new</span>);</span><br><span class="line">    map.put(<span class="string">&quot;orange&quot;</span>, Orange::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">giveMeFruit</span><span class="params">(String fruit, Integer weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(fruit.toLowerCase())</span><br><span class="line">        		.apply(weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法引用示例</strong></p>
<p>最普通的行为参数化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeigth().compareTo(a2.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inventory.sort(<span class="keyword">new</span> AppleComparator());</span><br></pre></td></tr></table></figure>

<p>匿名类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(<span class="keyword">new</span> Comparator&lt;Apple&gt; () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeigth().compareTo(a2.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort((Apple a1, Apple a2) -&gt;  a1.getWeigth().compareTo(a2.getWeight()));</span><br><span class="line"></span><br><span class="line">inventory.sort((a1, a2) -&gt;  a1.getWeigth().compareTo(a2.getWeight()));</span><br></pre></td></tr></table></figure>

<p>方法引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; c = Comparator.comparing((Apple a) -&gt; a.getWeight());</span><br><span class="line">inventory.sort(Comparator.comparing((a) -&gt; a.getWeight()));</span><br><span class="line">inventory.sort(Comparator.comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure>



<h4 id="复合Lambda"><a href="#复合Lambda" class="headerlink" title="复合Lambda"></a>复合Lambda</h4><p><strong>比较器复合</strong></p>
<p>逆序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(Comparator.comparing(Apple::getWeight).reversed());</span><br></pre></td></tr></table></figure>

<p>比较器链</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(Comparator.comparing(Apple::getWeight)</span><br><span class="line">               .reversed()</span><br><span class="line">               .thenComparing(Apple::getCountry));</span><br></pre></td></tr></table></figure>

<p><strong>谓词复合</strong></p>
<p>negate | and | or</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redApple = (Apple a) -&gt; a.getColor().equals(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">Predicate&lt;Apple&gt; notRedApple = redApple.negate();  <span class="comment">// 非</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>);  <span class="comment">// 与</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redAndHeavyApple = redApple.or(a -&gt; a.getWeight() &gt; <span class="number">150</span>);  <span class="comment">// 或</span></span><br></pre></td></tr></table></figure>

<p><strong>函数复合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g);  <span class="comment">// g(f(x))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.compose(g);  <span class="comment">// f(g(x))</span></span><br></pre></td></tr></table></figure>



<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="第四章-流"><a href="#第四章-流" class="headerlink" title="第四章 流"></a>第四章 流</h3><p>流可以允许以<strong>声明式</strong>的方式处理数据集合。（即仅表明需求，但是不用指定实现）</p>
<p>集合注重于数据的存储，流注重的是计算，使用内部迭代</p>
<p><strong>中间操作</strong>   </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>类型</th>
<th>返回类型</th>
<th>操作参数</th>
<th>函数描述符</th>
</tr>
</thead>
<tbody><tr>
<td>filter</td>
<td>中间</td>
<td>Stream<T></td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>map</td>
<td>中间</td>
<td>Stream<T></td>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
</tr>
<tr>
<td>flatMap</td>
<td>中间</td>
<td>Stream<T></td>
<td>Function&lt;T, Stream<R>&gt;</td>
<td>T -&gt; Stream<R></td>
</tr>
<tr>
<td>limit</td>
<td>中间</td>
<td>Stream<T></td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>skip</td>
<td>中间</td>
<td>Stream<T></td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>sorted</td>
<td>中间</td>
<td>Stream<T></td>
<td>Comparator<T></td>
<td>(T, T) -&gt; int</td>
</tr>
<tr>
<td>distinct</td>
<td>中间</td>
<td>Stream<T></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>终止操作</strong> </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>类型</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>forEach</td>
<td>终端</td>
<td>消费流中的每个元素并对其应用Lambda。这一操作返回void</td>
</tr>
<tr>
<td>count</td>
<td>终端</td>
<td>返回流中元素的个数。这一操作返回Long</td>
</tr>
<tr>
<td>collect</td>
<td>终端</td>
<td>把流归约成一个集合，比如List、Map甚至是Integer</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>操作</th>
<th>类型</th>
<th>返回类型</th>
<th>操作参数</th>
<th>函数描述符</th>
</tr>
</thead>
<tbody><tr>
<td>anyMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>noneMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>allMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>findAny</td>
<td>终端</td>
<td>Optional<T></td>
<td></td>
<td></td>
</tr>
<tr>
<td>findFirst</td>
<td>终端</td>
<td>Optional<T></td>
<td></td>
<td></td>
</tr>
<tr>
<td>forEach</td>
<td>终端</td>
<td>void</td>
<td>Consumer<T></td>
<td>T -&gt; void</td>
</tr>
<tr>
<td>collect</td>
<td>终端</td>
<td>R</td>
<td>Collector&lt;T, A, R&gt;</td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td>终端</td>
<td>Optional<T></td>
<td>BinaryOperator<T></td>
<td>(T, T) -&gt; T</td>
</tr>
<tr>
<td>count</td>
<td>终端</td>
<td>long</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = menu.stream()</span><br><span class="line">    					.filter(d -&gt; &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;filtering&quot;</span> + d.getName());</span><br><span class="line">                            <span class="keyword">return</span> d.getCalories() &gt; <span class="number">300</span>;</span><br><span class="line">                        &#125;)</span><br><span class="line">    					.map(d -&gt; &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;mapping&quot;</span> + d.getName());</span><br><span class="line">                            <span class="keyword">return</span> d.getName();</span><br><span class="line">                        &#125;)</span><br><span class="line">    					.limit(<span class="number">3</span>)</span><br><span class="line">    					.collect(toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">filtering pork</span></span><br><span class="line"><span class="comment">mapping pork</span></span><br><span class="line"><span class="comment">filtering beef</span></span><br><span class="line"><span class="comment">mapping beef</span></span><br><span class="line"><span class="comment">filtering chicken</span></span><br><span class="line"><span class="comment">mapping chicken</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>limit会进行<strong>短路</strong>，filter和map会进行<strong>循环合并</strong>。并且除非流水线上触发一个终端操作，否则中间操作不会执行任何处理。</p>
<h3 id="第五章-使用流"><a href="#第五章-使用流" class="headerlink" title="第五章 使用流"></a>第五章 使用流</h3><p>流的扁平化</p>
<p>map和flatMap的区别</p>
<p>flatMap中接收一个<strong>会返回Stream的函数</strong>，然后将其最终整合成一个Stream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">char</span>[]&gt; collect = words.stream().map(s -&gt; s.toCharArray()).distinct().collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 这里map所返回的就是一个Stream&lt;char[]&gt;，是一个数组流</span></span><br><span class="line"></span><br><span class="line">words.stream()</span><br><span class="line">    .map(word -&gt; word.toCharArray())</span><br><span class="line">    .map(Arrays::stream)    <span class="comment">// 这里就是将原来的数组流转换为字符流Stream&lt;Stream&lt;Character&gt;&gt;</span></span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">words.stream()</span><br><span class="line">    .map(word -&gt; word.toCharArray())</span><br><span class="line">    .flatMap(Arrays::stream)    <span class="comment">// 这里就是将原来的数组流转换为字符流Stream&lt;Character&gt;</span></span><br><span class="line">    .distince()</span><br><span class="line">    .collect(toList());</span><br><span class="line"><span class="comment">// flatMap中各个数组不是分别映射一个流，而是映射成流的内容。</span></span><br></pre></td></tr></table></figure>



<p><strong>例</strong>：给定[1, 2, 3]和[4, 5]，返回[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>[]&gt; pairs = numbers1.stream()</span><br><span class="line">    						.flatMap(i -&gt; numbers2.stream()</span><br><span class="line">                                    				.map(j -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;))</span><br><span class="line">    						.collect(toList());</span><br></pre></td></tr></table></figure>



<p><strong>查找和匹配</strong></p>
<p>终端操作  allMatch | anyMatch | noneMatch | findFirst | findAny</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (menu.stream().anyMatch(Dish::isVegetarian)) &#123;  <span class="comment">// 传入谓词，返回Boolean，有一个谓词返回true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;the menu has vegetable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (menu.stream().allMatch(Dish::isVegetarian)) &#123;  <span class="comment">// 传入谓词，返回Boolean，所有谓词都为true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;all vegetables&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (menu.stream().noneMatch(Dish::isVegetarian)) &#123;  <span class="comment">// 传入谓词，返回Boolean，没有谓词返回true的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;no vegetables&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findAny返回流中的任意元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; dish = </span><br><span class="line">menu.stream().filter(Dish::isVegetarian).findAny(); <span class="comment">// 返回任意一个蔬菜</span></span><br></pre></td></tr></table></figure>

<p>不过这里返回的是Optional，相当于是对null进行的封装，因为findAny可以找不到</p>
<p>Optional中有几个方法能规避空指针异常</p>
<p>isPresent()如果Optional中包含值则返回true，否则false</p>
<p>ifPresent(Consumer<T> block)如果存在值就执行Consumer的代码块</p>
<p>T get() 如果存在值返回值，否则<strong>抛出NoSuchElement异常</strong></p>
<p>T orElse(T other) 如果存在值返回值，否则返回括号中的默认值</p>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><p>将流中的元素反复结合起来，得到一个值。例如对集合中的数字进行求和操作即为归约</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"><span class="comment">// 传入两个参数</span></span><br><span class="line"><span class="comment">// 初始值，0</span></span><br><span class="line"><span class="comment">// BinaryOperator&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);  <span class="comment">// 静态方法的方法引用</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce(Integer::sum); </span><br><span class="line"><span class="comment">// 如果不给定初始值，那么就是返回Optional</span></span><br></pre></td></tr></table></figure>

<p>返回最大值和最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; max = nums.stream().reduce(Integer::max);  <span class="comment">// 静态方法</span></span><br><span class="line">Optional&lt;Integer&gt; max = nums.stream().reduce(Integer::min);  <span class="comment">// 静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer::max 就是 Math::max</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public static int max(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">    return Math.max(a, b);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h4><p>IntStream | DoubleStream | LongStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">    				.mapToInt(Dish::getCalories)  <span class="comment">// 映射到特定的数值流，返回IntStream</span></span><br><span class="line">    				.sum();  <span class="comment">// 为该原始类型流所特有</span></span><br></pre></td></tr></table></figure>

<p>IntStream中还支持max | min | average</p>
<p>IntStream中的map操作必须接收int并返回int（即为IntUnaryOperator，int -&gt; int）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</span><br><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed(); <span class="comment">// 将IntStream转换为Stream&lt;Integer&gt;</span></span><br></pre></td></tr></table></figure>

<p>特型化的Optional，OptionalInt | OptionalDouble | OptionalLong</p>
<blockquote>
<p>设计者认为sum操作可以用0来区分空流的状态（不可），但是max方法不能区分空流的状态，因此需要返回一个OptionalInt</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt maxCalories = menu.stream()</span><br><span class="line">    							.mapToInt(Dish::getCalories)</span><br><span class="line">    							.max();</span><br><span class="line">maxCalories.orElse(<span class="number">1</span>);  <span class="comment">// 这里不能使用get()方法，必须使用orElse指定一个默认值</span></span><br></pre></td></tr></table></figure>

<p><strong>数值范围</strong></p>
<p>range和rangeClosed可以生成一个数值范围的流，两个参数，一个初始值，一个结束值，range不包含结束值，rangeClosed包含结束值。两个方法为IntStream和LongStream的静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream evenNumbers = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    							.filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面的这个流没有终端操作，因此不会运行。</p>
<p><strong>数值流应用：勾股数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;  <span class="comment">// 手动赋值3</span></span><br><span class="line"></span><br><span class="line">Stream&lt;<span class="keyword">int</span>[]&gt; stream = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    .filter(b -&gt; Math.sqrt(a * a + b * b) % <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">    .boxed()</span><br><span class="line">    .map(b -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b, (<span class="keyword">int</span>) Math.sqrt(a * a + b * b)&#125;);</span><br><span class="line"></span><br><span class="line">Stream&lt;<span class="keyword">int</span>[]&gt; stream1 = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    .filter(b -&gt; Math.sqrt(a * a + b * b) % <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">    .mapToObj(b -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b, (<span class="keyword">int</span>) Math.sqrt(a * a + b * b)&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="keyword">int</span>[]&gt; pythagoreanTriples = </span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).boxed()</span><br><span class="line">    		.flatMap(a -&gt; </span><br><span class="line">                    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                            .filter(b -&gt; Math.sqrt(a * a + b * b) % <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">                            .mapToObj(b -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b, (<span class="keyword">int</span>) Math.sqrt(a * a + b * b)&#125;)</span><br><span class="line">                    );</span><br></pre></td></tr></table></figure>

<p><strong>构建流</strong></p>
<p>由值构建流，使用静态方法Stream.of</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;java 8&quot;</span>, <span class="string">&quot;lambda&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure>

<p>由数组创建流，使用Arrays.stream接收一个数组作为参数创建流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum  = Arrays.stream(numbers).sum();  <span class="comment">// 这里创建的是IntStream，所以可以使用sum方法</span></span><br></pre></td></tr></table></figure>

<p>由文件生成流。在java.nio.file.Files中有很多静态方法都会返回一个流。例如，Files.lines</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(Path.get(<span class="string">&quot;data.txt&quot;</span>), Charset.defaultCharaset())) &#123;</span><br><span class="line">    uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">        			.distinct()</span><br><span class="line">        			.count();</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建无限流</strong></p>
<p>有两个静态方法可以从函数生成流：Stream.iterate和Stream.generate</p>
<p>① iterate（有状态）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)  <span class="comment">// 接收一个初始值和一个UnaryOperator&lt;T&gt;</span></span><br><span class="line">    	.limit(<span class="number">10</span>)</span><br><span class="line">    	.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>例子：生成斐波那契元组(1, 1), (1, 2), (2, 3), (3, 5), (5, 8), (8, 13)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, x -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x[<span class="number">1</span>], x[<span class="number">0</span>] + x[<span class="number">1</span>]))</span><br><span class="line">    	.limit(<span class="number">20</span>)</span><br><span class="line">    	.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>② generate（无状态，并行时安全）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)  <span class="comment">// generate接收一个Supplier用以生成新的值</span></span><br><span class="line">    	.limit(<span class="number">5</span>)</span><br><span class="line">    	.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream ones = IntStream.generate(() -&gt; <span class="number">1</span>);  <span class="comment">// 生成一个全是1的无限流。还需要注意这里用的是IntStream，接收一个IntSupplier</span></span><br></pre></td></tr></table></figure>



<h3 id="第六章-用流收集数据-collect"><a href="#第六章-用流收集数据-collect" class="headerlink" title="第六章 用流收集数据 collect"></a>第六章 用流收集数据 collect</h3><p>collect接收一个Collector接口的实现，在Collectors类中提供了预定义的收集器</p>
<h4 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> howManyDishes = menu.stream().collect(Collecors.counting());</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> howManyDishes = menu.stream().count();  <span class="comment">// 可以直接写为这种形式</span></span><br></pre></td></tr></table></figure>

<p>本章中将引入import static java.util.stream.Collectors.*; 用以简化 Collectors.counting() 为 counting()</p>
<p>最大值和最小值分别为 Collectors.maxBy 和 Collectors.minBy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);</span><br><span class="line"></span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));</span><br></pre></td></tr></table></figure>



<p>汇总有专门的方法Collectors.summingInt，可以接收一个对象映射成求和所需的int的函数。Collectors.averagingInt</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));</span><br></pre></td></tr></table></figure>

<p>所有方法的集中 summarizingInt</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这个IntSummaryStatistics类中包含count, sum, min, average, max</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>连接字符串</p>
<p>joining方法可以将流中的每一个对象应用toString方法得到的所有字符串连接成一个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().map(Dish::getName).collect(joining(<span class="string">&quot;, &quot;</span>));  <span class="comment">// 以&quot;, &quot;作为分割拼接</span></span><br></pre></td></tr></table></figure>



<p><strong>广义的归约汇总</strong></p>
<p>以上归约收集器都可作为 reducing 的衍生</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().collect(reducing(<span class="number">0</span>, Dish::getCalories, (i, j) -&gt; i + j));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().collect(reducing(<span class="number">0</span>, Dish::getCalories, Integer::sum));  <span class="comment">// 可简化为此</span></span><br></pre></td></tr></table></figure>

<p>Collectors.reducing需要三个参数</p>
<ol>
<li>初始值</li>
<li>映射方法，这里将对象映射为一个int</li>
<li>BinaryOperator</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(reducing((d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2));  <span class="comment">// 单参数</span></span><br></pre></td></tr></table></figure>

<p>单参数的情况，即为将流中的第一项作为初始值，</p>
<h4 id="元素分组"><a href="#元素分组" class="headerlink" title="元素分组"></a>元素分组</h4><p>使用groupingBy方法，该方法接收一个Function，根据Function所返回的参数进行分类。最终生成一个map，key为进行分类的参数，value则为流中的组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(groupingBy(Dish::getType));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&#123;FISH=[prawns, salmon], OTHER=[french fires, rice, pizza], MEAT=[pork, beef]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CaloricLevel</span> </span>&#123;Diet, Noraml, Fat&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream().collect(</span><br><span class="line">																	groupingBy(dish -&gt; &#123;</span><br><span class="line">                                                                        <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.Diet;</span><br><span class="line">                                                                        <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.Normal;</span><br><span class="line">                                                                        <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.Fat;</span><br><span class="line">                                                                    &#125;));</span><br></pre></td></tr></table></figure>

<p><strong>多级分组</strong></p>
<p>由两个参数的groupingBy实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishedByTypeCaloricLevel = menu.stream().collect(</span><br><span class="line">																						groupingBy(Dish::getType, </span><br><span class="line">                                                                                                  	groupingBygroupingBy(dish -&gt; &#123;</span><br><span class="line">                                                                        <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.Diet;</span><br><span class="line">                                                                        <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.Normal;</span><br><span class="line">                                                                        <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.Fat;</span><br><span class="line">                                                                                                        &#125;)))</span><br></pre></td></tr></table></figure>

<p>这里的第二个参数就是最后生成的map中的value值，如果如前的一个参数的版本就是流中的值，而这里用第二个参数指定的话就是该参数返回的值（也应该是终止操作）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect(groupingBy(Dish::getType, counting()));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回 &#123;Meat=3, Fish=2, Other=4&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>普通的单参数groupingBy(f) 是 groupingBy(f, toList()) 的简化</p>
<p>对收集器中的值进行转换，也就是对groupingBy的第二个参数使用 Collectors.collectingAndThen 进行替代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Dish&gt; mostCaloricByType = menu.stream().collect(groupingBy(Dish::getType, </span><br><span class="line">                                                                         collectingAndThen(</span><br><span class="line">                                                                         		maxBy(comparingInt(Dish::getCalories)), </span><br><span class="line">                                                                         					Optional::get)</span><br><span class="line">                                                                         				   )</span><br><span class="line">                                                              				)</span><br></pre></td></tr></table></figure>



<h4 id="元素分区"><a href="#元素分区" class="headerlink" title="元素分区"></a>元素分区</h4><p>分区是分组的特殊情况：由一个<strong>谓词</strong>作为分类函数，这个函数被称为「分区函数」。Map的键就为两组：true或false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu = </span><br><span class="line">			menu.stream().collect(partitioningBy(Dish::isVegetarian));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回</span></span><br><span class="line"><span class="comment">&#123;false=[pork, beef, chicken, prawns, salmon],</span></span><br><span class="line"><span class="comment">true=[french fries, rice, season fruit, pizza]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通过Map键为true的值，就可以找出所有的素菜菜肴</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianDishes = partitionedMenu.get(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Dish&gt; vegetarianDishes = </span><br><span class="line">    menu.stream().filter(Dish::isVegetarian).collect(toList());</span><br></pre></td></tr></table></figure>

<p>分区的好处在于保留了分区函数返回true和false的<strong>两套流元素列表</strong>。</p>
<p>partitioningBy有另一个重载版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; vegetarianDishesByType = </span><br><span class="line">    menu.stream().collect(</span><br><span class="line">		partitioningBy(Dish::isVegetarian, groupingBy(Dish::getType)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">产生一个二级Map</span></span><br><span class="line"><span class="comment">&#123;false=&#123;FISH=[prawns, salmon], MEAT=[pork, beef, chicken]&#125;,</span></span><br><span class="line"><span class="comment">true=&#123;OTHER=[french fries, rice, season fruit, pizza]&#125;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Dish&gt; mostCaloricPartitionedByVegetarian = </span><br><span class="line">    menu.stream().collect(</span><br><span class="line">		partitioningBy(Dish::isVegetarian, </span><br><span class="line">                      collectingAndThen(maxBy(comparingInt(Dish::getCalories)), Optional::get)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">&#123;false=pork, true=pizaa&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>应用：</strong>将数字按质数和非质数分区</p>
<p>编写一个方法，接收一个参数<code>int n</code>， 并将前n个自然数分为质数和非质数。</p>
<p>Step 1 判断该数是否为质数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> candidate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">2</span>, candidate).noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> candidate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>)Math.sqrt((<span class="keyword">double</span>)candidate);</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidateRoot).noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step 2 分区函数分离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed().</span><br><span class="line">        collect(partitioningBy(i -&gt; isPrime(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-Collectors类的静态工厂方法"><a href="#总结-Collectors类的静态工厂方法" class="headerlink" title="总结 Collectors类的静态工厂方法"></a>总结 Collectors类的静态工厂方法</h4><table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>toList</td>
<td>List<T></td>
<td>把流中的所有项目收集到一个List</td>
<td>List<Dish> dishes = menuStream.collect(toList());</td>
</tr>
<tr>
<td>toSet</td>
<td>Set<T></td>
<td>把流中的所有项目收集到一个Set，没有重复项</td>
<td>Set<Dish> dishes = menuStream.collect(toSet());</td>
</tr>
<tr>
<td>toCollection</td>
<td>Collection<T></td>
<td>把流中所有项目收集到<strong>给定的供应源创建的集合</strong></td>
<td>ArrayList<Dish> dishes = menuStream.collect(toCollection(ArrayList::new));<br />Collection<Dish> dishes = menuStream.collect(toCollection());</td>
</tr>
<tr>
<td>counting</td>
<td>Long</td>
<td>计算流中元素的个数</td>
<td>long howManyDishes = menuStream.collect(counting());</td>
</tr>
<tr>
<td>summingInt</td>
<td>Integer</td>
<td>对流中项目的一个整数属性求和</td>
<td>int totalCalories = menuStream.collect(summingInt(Dish::getCalories));</td>
</tr>
<tr>
<td>averagingInt</td>
<td>Double</td>
<td>计算流中项目Integer属性的平均值</td>
<td>double avgCalories = menuStream.collect(averagingInt(Dish::getCalories));</td>
</tr>
<tr>
<td>summarizingInt</td>
<td>IntSummaryStatistics</td>
<td>收集关于流中项目Integer属性的统计值</td>
<td>IntSummaryStatistics menuStatistics = menuStream.collect(summarizingInt(Dish::getCalories));</td>
</tr>
<tr>
<td>joining</td>
<td>String</td>
<td>连接对流中每个项目调用toString方法所生成的字符串</td>
<td>String shortMenu = menuStream.collect(joining(“, “));</td>
</tr>
<tr>
<td>maxBy</td>
<td>Optional<T></td>
<td>选出流中最大元素，用Optional进行包裹</td>
<td>Optional<Dish> fattest = menuStream.collect(maxBy(comparingInt(Dish::getCalories)));</td>
</tr>
<tr>
<td>minBy</td>
<td>Optinal<T></td>
<td>-</td>
<td>Optional<Dish> lightest = menuStream.collect(minBy(comparingInt(Dish::getCalories)));</td>
</tr>
<tr>
<td>reducing</td>
<td>规约操作产生的类型</td>
<td>从初始值开始，利用BinaryOperator与流中的元素进行结合，将流归约为单个值</td>
<td>int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));</td>
</tr>
<tr>
<td>collectingAndThen</td>
<td>转换函数返回的类型</td>
<td>包裹另一个收集器，并对该收集器的结果应用转换函数</td>
<td>int howManyDishes = menuStream.collect(collectionAndThen(toList(), List:;size));</td>
</tr>
<tr>
<td>groupingBy</td>
<td>Map&lt;K, List<T>&gt;</td>
<td>分组</td>
<td>Map&lt;Dish.Type, List<Dish>&gt; dishesByType = menuStream.collect(groupingBy(Dish::getType));</td>
</tr>
<tr>
<td>partitioningBy</td>
<td>Map&lt;Boolean, List<T>&gt;</td>
<td>分区</td>
<td>Map&lt;Boolean, List<Dish>&gt; vegetarianDishes = menuStream.collect(partitioningBy(Dish::isVegetarain));</td>
</tr>
</tbody></table>
<p>所有这些收集器都是对Collector接口的实现</p>
<h4 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h4><p>通过toList方法来探究Collector接口是如何定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>T 流中要收集的项目的泛型</li>
<li>A 累加器的类型，累加器是在收集过程中用于累计部分结果的对象</li>
<li>R 收集操作的对象的类型</li>
</ul>
<p>其中的五个方法，前四个方法都会返回一个可以被collect方法调用的函数，而第五个方法则提供一系列特征，告诉collect方法再执行归约操作的时候可以应用哪些优化</p>
<p>自定义一个ToListCollector<T>类，将Stream<T>中所有的元素收集到一个List<T>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToListCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">List</span>&lt;<span class="title">T</span>&gt;, <span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure>



<ol>
<li>supplier</li>
</ol>
<p>该方法必须返回一个结果为空的Supplier，也就是一个无参数函数，用于数据收集过程中使用。</p>
<p>在自定义的ToListCollector<T>类中，实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种方式</span></span><br><span class="line"><span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">    <span class="keyword">return</span> ArrayList::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将元素添加到结果容器：accumulator方法</li>
</ol>
<p>accumulator方法返回执行归约操作的函数。当遍历到流中的第 n 个元素时，这个函数执行时会有两个参数：保存归约结果的累加器（已收集了流中前 n-1 个项目），还有第 n 个元素本身。</p>
<p>在自定义的ToListCollector<T>类中，实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">    <span class="keyword">return</span> (list, item) -&gt; list.add(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种版本</span></span><br><span class="line"><span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">    <span class="keyword">return</span> List::add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/19/Vim/" rel="next" title="Vim">
                <i class="fa fa-chevron-left"></i> Vim
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/16/Maven/" rel="prev" title="Maven">
                Maven <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">第一部分 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%B3%E5%BF%83Java-8"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 为什么要关心Java 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%80%9A%E8%BF%87%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">第二章 通过行为参数化传递代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">第三章 Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%90%88Lambda"><span class="nav-number">1.3.2.</span> <span class="nav-text">复合Lambda</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="nav-number">2.</span> <span class="nav-text">第二部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B5%81"><span class="nav-number">2.1.</span> <span class="nav-text">第四章 流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%B5%81"><span class="nav-number">2.2.</span> <span class="nav-text">第五章 使用流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E7%BA%A6"><span class="nav-number">2.2.1.</span> <span class="nav-text">归约</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%B5%81%E7%89%B9%E5%8C%96"><span class="nav-number">2.2.2.</span> <span class="nav-text">原始类型流特化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE-collect"><span class="nav-number">2.3.</span> <span class="nav-text">第六章 用流收集数据 collect</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E7%BA%A6%E5%92%8C%E6%B1%87%E6%80%BB"><span class="nav-number">2.3.1.</span> <span class="nav-text">归约和汇总</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%88%86%E7%BB%84"><span class="nav-number">2.3.2.</span> <span class="nav-text">元素分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%88%86%E5%8C%BA"><span class="nav-number">2.3.3.</span> <span class="nav-text">元素分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-Collectors%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.4.</span> <span class="nav-text">总结 Collectors类的静态工厂方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.3.5.</span> <span class="nav-text">收集器接口</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hzq</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
